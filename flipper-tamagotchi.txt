#include <furi.h>
#include <gui/gui.h>
#include <input/input.h>
#include <stdlib.h>
#include <dolphin/dolphin.h>

typedef struct {
    int hunger;     // 0-100
    int happiness;  // 0-100
    int energy;     // 0-100
    int age;        // en jours
    bool sleeping;
    uint32_t last_update;
} Pet;

typedef struct {
    Pet* pet;
    FuriMutex* mutex;
} FlipperGotchiState;

// États du jeu
static Pet pet;
static FlipperGotchiState* state;

// Fonctions de gestion du pet
void init_pet() {
    pet.hunger = 50;
    pet.happiness = 50;
    pet.energy = 100;
    pet.age = 0;
    pet.sleeping = false;
    pet.last_update = furi_get_tick();
}

void update_pet_stats() {
    uint32_t current_time = furi_get_tick();
    uint32_t delta = (current_time - pet.last_update) / 1000; // Convertir en secondes
    
    if(delta > 0) {
        // Diminuer les stats avec le temps
        pet.hunger = MAX(0, pet.hunger - (delta / 300));
        pet.happiness = MAX(0, pet.happiness - (delta / 600));
        
        if(pet.sleeping) {
            pet.energy = MIN(100, pet.energy + (delta / 120));
        } else {
            pet.energy = MAX(0, pet.energy - (delta / 400));
        }
        
        // Mettre à jour l'âge (1 jour = 24h réelles)
        pet.age += delta / 86400;
        
        pet.last_update = current_time;
    }
}

void feed_pet() {
    if(!pet.sleeping) {
        pet.hunger = MIN(100, pet.hunger + 30);
        pet.happiness = MIN(100, pet.happiness + 5);
    }
}

void play_with_pet() {
    if(!pet.sleeping && pet.energy > 20) {
        pet.happiness = MIN(100, pet.happiness + 20);
        pet.energy = MAX(0, pet.energy - 20);
        pet.hunger = MAX(0, pet.hunger - 10);
    }
}

void toggle_sleep() {
    pet.sleeping = !pet.sleeping;
}

// Callback pour le dessin de l'interface
static void render_callback(Canvas* canvas, void* ctx) {
    FlipperGotchiState* state = ctx;
    furi_mutex_acquire(state->mutex, FuriWaitForever);
    
    canvas_clear(canvas);
    canvas_set_font(canvas, FontPrimary);
    
    // Dessiner le visage du pet
    uint8_t x = 64, y = 32;
    if(state->pet->sleeping) {
        // Visage endormi
        canvas_draw_circle(canvas, x, y, 20);
        canvas_draw_str(canvas, x-10, y, "zzZ");
    } else {
        // Visage normal
        canvas_draw_circle(canvas, x, y, 20);
        canvas_draw_circle(canvas, x-7, y-5, 3);  // œil gauche
        canvas_draw_circle(canvas, x+7, y-5, 3);  // œil droit
        
        // Expression selon le bonheur
        if(state->pet->happiness > 70) {
            canvas_draw_circle(canvas, x, y+5, 5);  // sourire
        } else if(state->pet->happiness < 30) {
            canvas_draw_line(canvas, x-5, y+8, x+5, y+8);  // triste
        }
    }
    
    // Afficher les stats
    canvas_set_font(canvas, FontSecondary);
    char stats[64];
    snprintf(stats, sizeof(stats), "Faim: %d%%", state->pet->hunger);
    canvas_draw_str(canvas, 2, 10, stats);
    
    snprintf(stats, sizeof(stats), "Bonheur: %d%%", state->pet->happiness);
    canvas_draw_str(canvas, 2, 20, stats);
    
    snprintf(stats, sizeof(stats), "Energie: %d%%", state->pet->energy);
    canvas_draw_str(canvas, 2, 30, stats);
    
    snprintf(stats, sizeof(stats), "Age: %d jours", state->pet->age);
    canvas_draw_str(canvas, 2, 40, stats);
    
    // Afficher les contrôles
    canvas_draw_str(canvas, 2, 60, "↑:Nourrir ↓:Jouer ⟲:Dormir");
    
    furi_mutex_release(state->mutex);
}

// Callback pour les entrées utilisateur
static void input_callback(InputEvent* input_event, void* ctx) {
    FlipperGotchiState* state = ctx;
    furi_mutex_acquire(state->mutex, FuriWaitForever);
    
    if(input_event->type == InputTypeShort) {
        switch(input_event->key) {
            case InputKeyUp:
                feed_pet();
                break;
            case InputKeyDown:
                play_with_pet();
                break;
            case InputKeyBack:
                toggle_sleep();
                break;
            default:
                break;
        }
    }
    
    furi_mutex_release(state->mutex);
}

// Point d'entrée de l'application
int32_t flipper_gotchi_app(void* p) {
    UNUSED(p);
    
    // Initialisation
    state = malloc(sizeof(FlipperGotchiState));
    state->pet = &pet;
    state->mutex = furi_mutex_alloc(FuriMutexTypeNormal);
    
    init_pet();
    
    // Configuration de l'interface graphique
    ViewPort* view_port = view_port_alloc();
    view_port_draw_callback_set(view_port, render_callback, state);
    view_port_input_callback_set(view_port, input_callback, state);
    
    // Création de la GUI
    Gui* gui = furi_record_open(RECORD_GUI);
    gui_add_view_port(gui, view_port, GuiLayerFullscreen);
    
    // Boucle principale
    while(1) {
        furi_mutex_acquire(state->mutex, FuriWaitForever);
        update_pet_stats();
        furi_mutex_release(state->mutex);
        
        furi_delay_ms(1000);  // Mise à jour toutes les secondes
    }
    
    // Nettoyage
    gui_remove_view_port(gui, view_port);
    view_port_free(view_port);
    furi_mutex_free(state->mutex);
    free(state);
    
    return 0;
}
